<script lang="ts">
  import type { Feature } from 'geojson';
  import { createEventDispatcher, onDestroy } from 'svelte';
  import { getId, mapContext } from './context';
  import { combineFilters, isClusterFilter } from './filters';
  import { geoCentroid } from 'd3-geo';
  import Marker from './Marker.svelte';
  import FillLayer from './FillLayer.svelte';
  import type { MapLibreZoomEvent } from 'maplibre-gl';
  import type { MarkerClickInfo } from './types';

  type FeatureWithId = Feature & { id: string | number };

  interface ExtendedMarkerClickInfo extends MarkerClickInfo {
    source: string | null;
    feature: FeatureWithId;
  }

  const { map, source, minzoom: minZoomContext, maxzoom: maxZoomContext } = mapContext();
  const dispatch = createEventDispatcher<{
    click: ExtendedMarkerClickInfo;
    dblclick: ExtendedMarkerClickInfo;
    contextmenu: ExtendedMarkerClickInfo;
    drag: ExtendedMarkerClickInfo;
    dragstart: ExtendedMarkerClickInfo;
    dragend: ExtendedMarkerClickInfo;
  }>();

  export let applyToClusters: boolean | undefined = undefined;
  export let filter: maplibregl.ExpressionSpecification | undefined = undefined;
  /** How to calculate the coordinates of the marker.
   * @default Calls d3.geoCentroid` on the feature. */
  export let markerLngLat: (feature: Feature) => [number, number] = geoCentroid;
  /** Handle mouse events */
  export let interactive = true;
  /** Make markers tabbable and add the button role. */
  export let asButton = false;
  export let draggable = false;
  export let minzoom: number | undefined = undefined;
  export let maxzoom: number | undefined = undefined;
  export let hovered: Feature | null = null;
  /** The z-index of the markers. This can also be set via CSS classes using the `class` prop.
   * If a function is provided, it will be called with each feature as an argument. */
  export let zIndex: number | ((feature: GeoJSON.Feature) => number) | undefined = undefined;
  /** CSS classes to apply to each marker */
  let className: string | undefined = undefined;
  export { className as class };

  $: actualMinZoom = minzoom ?? $minZoomContext;
  $: actualMaxZoom = maxzoom ?? $maxZoomContext;
  $: actualFilter = combineFilters('all', isClusterFilter(applyToClusters), filter);

  let installedHandlers = false;
  function setupHandlers() {
    if (!$map) {
      return;
    }

    installedHandlers = true;

    $map.on('zoom', handleZoom);
    $map.on('move', updateMarkers);
    $map.on('moveend', updateMarkers);
    if (!$map.loaded()) {
      updateMarkers();
    } else {
      $map.once('load', updateMarkers);
    }
  }

  function handleData(e: maplibregl.MapSourceDataEvent) {
    if (e.sourceId === $source && e.isSourceLoaded) {
      if (installedHandlers) {
        updateMarkers();
      } else {
        setupHandlers();
      }
    }
  }

  onDestroy(() => {
    if (!$map) {
      return;
    }

    $map.off('zoom', handleZoom);
    $map.off('move', updateMarkers);
    $map.off('moveend', updateMarkers);
    $map.off('sourcedata', handleData);
  });

  $: if ($map && $source) {
    let sourceObj = $map.getSource($source);
    if (sourceObj?.loaded()) {
      setupHandlers();
    } else {
      // Need to wait for the data to load
      $map.on('sourcedata', handleData);
    }
  }

  let features: FeatureWithId[] = [];
  function updateMarkers() {
    if (!$map || !$source) {
      return;
    }

    let featureList = $map.querySourceFeatures($source, {
      filter: actualFilter,
    });

    // Need to dedupe the results of featureList
    let featureMap = new Map<string | number, FeatureWithId>();
    for (let feature of featureList) {
      if (!feature.id) {
        if (feature.properties?.cluster_id) {
          feature.id = 'autocluster_' + feature.properties.cluster_id;
        } else {
          feature.id = getId('autofeat');
        }
      }
      featureMap.set(feature.id, feature as FeatureWithId);
    }

    // Sort the features by ID so that the #each loop doesn't think the order ever changes. If the order
    // changes then it tries to move the element around which interferes with the map's management of the
    // marker element.
    features = [...featureMap.values()].sort((a, b) =>
      a.id.toString().localeCompare(b.id.toString())
    );
  }

  let zoom = $map?.getZoom() ?? 0;
  function handleZoom(e: MapLibreZoomEvent) {
    zoom = $map!.getZoom();
    updateMarkers();
  }
</script>

<!--
@component Manages a set of HTML markers for the features in a source.
  This acts similar to a Layer component, but is not actually registered with
the map as a layer. Markers for non-point features are placed at the geometry's center.
-->

<!-- Set up an invisible layer so that querySourceFeatures has something to search through. -->
<FillLayer {minzoom} {maxzoom} paint={{ 'fill-opacity': 0 }} beforeLayerType="symbol" />

{#if zoom >= actualMinZoom && zoom <= actualMaxZoom}
  {#each features as feature (feature.id)}
    {@const c = markerLngLat(feature)}
    {@const z = typeof zIndex === 'function' ? zIndex(feature) : zIndex}
    <Marker
      {asButton}
      {interactive}
      {draggable}
      class={className}
      zIndex={z}
      lngLat={c}
      on:mouseenter={() => {
        hovered = feature;
      }}
      on:mouseleave={() => {
        if (hovered?.id === feature.id) {
          hovered = null;
        }
      }}
      on:dragstart={(e) => dispatch('dragstart', { ...e.detail, source: $source, feature })}
      on:drag={(e) => dispatch('drag', { ...e.detail, source: $source, feature })}
      on:dragend={(e) => dispatch('dragend', { ...e.detail, source: $source, feature })}
      on:click={(e) => dispatch('click', { ...e.detail, source: $source, feature })}
      on:dblclick={(e) => dispatch('dblclick', { ...e.detail, source: $source, feature })}
      on:contextmenu={(e) => dispatch('contextmenu', { ...e.detail, source: $source, feature })}
    >
      <slot {feature} position={c} />
    </Marker>
  {/each}
{/if}
