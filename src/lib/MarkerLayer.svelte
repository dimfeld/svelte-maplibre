<script lang="ts">
  import { run } from 'svelte/legacy';

  import type { Feature } from 'geojson';
  import { createEventDispatcher, onDestroy } from 'svelte';
  import { getId, mapContext } from './context';
  import { combineFilters, isClusterFilter } from './filters';
  import { geoCentroid } from 'd3-geo';
  import Marker from './Marker.svelte';
  import FillLayer from './FillLayer.svelte';
  import type { MapLibreZoomEvent } from 'maplibre-gl';
  import type { MarkerClickInfo } from './types';
  import { dequal } from 'dequal/lite';

  type FeatureWithId = Feature & { id: string | number };

  interface ExtendedMarkerClickInfo extends MarkerClickInfo {
    source: string | null;
    feature: FeatureWithId;
  }

  const { map, source, minzoom: minZoomContext, maxzoom: maxZoomContext } = mapContext();
  const dispatch = createEventDispatcher<{
    click: ExtendedMarkerClickInfo;
    dblclick: ExtendedMarkerClickInfo;
    contextmenu: ExtendedMarkerClickInfo;
    drag: ExtendedMarkerClickInfo;
    dragstart: ExtendedMarkerClickInfo;
    dragend: ExtendedMarkerClickInfo;
  }>();

  /** CSS classes to apply to each marker */
  interface Props {
    applyToClusters?: boolean | undefined;
    filter?: maplibregl.ExpressionSpecification | undefined;
    /** How to calculate the coordinates of the marker.
     * @default Calls d3.geoCentroid` on the feature. */
    markerLngLat?: (feature: Feature) => [number, number];
    /** Handle mouse events */
    interactive?: boolean;
    /** Make markers tabbable and add the button role. */
    asButton?: boolean;
    draggable?: boolean;
    minzoom?: number | undefined;
    maxzoom?: number | undefined;
    hovered?: Feature | null;
    /** The z-index of the markers. This can also be set via CSS classes using the `class` prop.
     * If a function is provided, it will be called with each feature as an argument. */
    zIndex?: number | ((feature: GeoJSON.Feature) => number) | undefined;
    class?: string | undefined;
    children?: import('svelte').Snippet<[any]>;
  }

  let {
    applyToClusters = undefined,
    filter = undefined,
    markerLngLat = geoCentroid,
    interactive = true,
    asButton = false,
    draggable = false,
    minzoom = undefined,
    maxzoom = undefined,
    hovered = $bindable(null),
    zIndex = undefined,
    class: className = undefined,
    children,
  }: Props = $props();

  let actualMinZoom = $derived(minzoom ?? $minZoomContext);
  let actualMaxZoom = $derived(maxzoom ?? $maxZoomContext);
  let actualFilter = $derived(combineFilters('all', isClusterFilter(applyToClusters), filter));

  let installedHandlers = false;
  function setupHandlers() {
    if (!$map) {
      return;
    }

    installedHandlers = true;

    $map.on('zoom', handleZoom);
    $map.on('move', updateMarkers);
    $map.on('moveend', updateMarkers);
    if (!$map.loaded()) {
      updateMarkers();
    } else {
      $map.once('load', updateMarkers);
    }
  }

  function handleData(e: maplibregl.MapSourceDataEvent) {
    if (e.sourceId === $source && e.isSourceLoaded) {
      if (installedHandlers) {
        updateMarkers();
      } else {
        setupHandlers();
      }
    }
  }

  onDestroy(() => {
    if (!$map) {
      return;
    }

    $map.off('zoom', handleZoom);
    $map.off('move', updateMarkers);
    $map.off('moveend', updateMarkers);
    $map.off('sourcedata', handleData);
  });

  run(() => {
    if ($map && $source) {
      let sourceObj = $map.getSource($source);
      if (sourceObj?.loaded()) {
        setupHandlers();
      } else {
        // Need to wait for the data to load
        $map.on('sourcedata', handleData);
      }
    }
  });
  let features: Array<FeatureWithId> = $state([]);
  function stripAutoFeatId(f: FeatureWithId) {
    if (f.id.toString().startsWith('autocluster_')) {
      return 'autocluster';
    }
    if (f.id.toString().startsWith('autofeat')) {
      return 'autofeat';
    }
    return f.id;
  }
  function someFeaturesChanged(current: Array<FeatureWithId>, next: Array<FeatureWithId>) {
    return (
      current.length !== next.length ||
      next.some((nextValue, idx) => {
        const currentValue = current[idx];
        return !dequal(
          {
            ...(currentValue as maplibregl.MapGeoJSONFeature)?.toJSON(),
            id: currentValue ? stripAutoFeatId(currentValue) : undefined,
          },
          {
            ...(nextValue as maplibregl.MapGeoJSONFeature).toJSON(),
            id: stripAutoFeatId(nextValue),
          }
        );
      })
    );
  }
  function updateMarkers() {
    if (!$map || !$source) {
      return;
    }

    let featureList = $map.querySourceFeatures($source, {
      filter: actualFilter,
    });

    // Need to dedupe the results of featureList
    let featureMap = new Map<string | number, FeatureWithId>();
    for (let feature of featureList) {
      if (!feature.id) {
        if (feature.properties?.cluster_id) {
          feature.id = 'autocluster_' + feature.properties.cluster_id;
        } else {
          feature.id = getId('autofeat');
        }
      }
      featureMap.set(feature.id, feature as FeatureWithId);
    }

    // Sort the features by ID so that the #each loop doesn't think the order ever changes. If the order
    // changes then it tries to move the element around which interferes with the map's management of the
    // marker element.
    const sorted = [...featureMap.values()].sort((a, b) =>
      a.id.toString().localeCompare(b.id.toString())
    );

    const currentFeatures = features;
    // Don't cause markers to rerender if nothing has changed.
    if (!someFeaturesChanged(currentFeatures, sorted)) {
      return;
    }

    features = sorted;
  }

  let zoom = $state($map?.getZoom() ?? 0);
  function handleZoom(e: MapLibreZoomEvent) {
    zoom = $map!.getZoom();
    updateMarkers();
  }
</script>

<!--
@component Manages a set of HTML markers for the features in a source.
  This acts similar to a Layer component, but is not actually registered with
the map as a layer. Markers for non-point features are placed at the geometry's center.
-->

<!-- Set up an invisible layer so that querySourceFeatures has something to search through. -->
<FillLayer {minzoom} {maxzoom} paint={{ 'fill-opacity': 0 }} beforeLayerType="symbol" />

{#if zoom >= actualMinZoom && zoom <= actualMaxZoom}
  {#each features as feature (feature.id)}
    {@const c = markerLngLat(feature)}
    {@const z = typeof zIndex === 'function' ? zIndex(feature) : zIndex}
    <Marker
      {asButton}
      {interactive}
      {draggable}
      class={className}
      zIndex={z}
      lngLat={c}
      on:mouseenter={() => {
        hovered = feature;
      }}
      on:mouseleave={() => {
        if (hovered?.id === feature.id) {
          hovered = null;
        }
      }}
      on:dragstart={(e) => dispatch('dragstart', { ...e.detail, source: $source, feature })}
      on:drag={(e) => dispatch('drag', { ...e.detail, source: $source, feature })}
      on:dragend={(e) => dispatch('dragend', { ...e.detail, source: $source, feature })}
      on:click={(e) => dispatch('click', { ...e.detail, source: $source, feature })}
      on:dblclick={(e) => dispatch('dblclick', { ...e.detail, source: $source, feature })}
      on:contextmenu={(e) => dispatch('contextmenu', { ...e.detail, source: $source, feature })}
    >
      {@render children?.({ feature, position: c })}
    </Marker>
  {/each}
{/if}
